---
export interface Props {
  id?: string;
}

const { id = 'results-table' } = Astro.props;
---

<div id={id} class="results-container hidden">
  <div id={`${id}-content`} class="results-content">
    <!-- Results will be dynamically inserted here -->
  </div>

  <div class="results-actions">
    <button id={`${id}-export`} class="btn btn-primary" type="button">
      Export to CSV
    </button>
  </div>
</div>

<style is:global>
  .results-container {
    margin-top: 3rem;
    padding: 0;
    max-width: 1200px;
    margin-left: auto;
    margin-right: auto;
  }

  .results-content {
    min-height: 200px;
    padding: 0 1rem;
  }

  /* Card styles */
  .card {
    background: white;
    border: 1px solid #d1d5db;
    border-radius: 8px;
    margin-bottom: 1.5rem;
    overflow: hidden;
  }

  .card-header {
    padding: 1rem 1.25rem;
    background: #1a1a1a;
    border-bottom: 1px solid #e5e7eb;
    font-weight: 600;
    font-size: 0.875rem;
    color: white;
    text-align: center;
    text-transform: uppercase;
    letter-spacing: 0.05em;
  }

  .card-body {
    padding: 0;
  }

  /* Lab info styles */
  .lab-info-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
    gap: 0;
    padding: 1rem 1.25rem;
  }

  .lab-info-item {
    display: flex;
    justify-content: space-between;
    padding: 0.5rem 0;
    border-bottom: 1px solid #f3f4f6;
  }

  .lab-info-label {
    font-size: 0.875rem;
    color: #6b7280;
    font-weight: 500;
  }

  .lab-info-value {
    font-size: 0.875rem;
    color: #111827;
    font-weight: 600;
    text-align: right;
  }

  /* Test table styles */
  .test-table {
    width: 100%;
    border-collapse: collapse;
  }

  .test-table thead {
    background: #f3f4f6;
  }

  .test-table thead tr {
    background: #f3f4f6;
  }

  .test-table th {
    text-align: left;
    padding: 0.75rem 1rem;
    font-weight: 600;
    font-size: 0.75rem;
    color: #374151;
    border-bottom: 1px solid #e5e7eb;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    background: #f3f4f6;
  }

  .test-table th.value-header {
    text-align: right;
  }

  .test-table th.date-header,
  .test-table th.flag-header {
    text-align: center;
  }

  .test-table th.range-header {
    text-align: center;
  }

  .test-table tbody tr {
    border-bottom: 1px solid #f3f4f6;
  }

  .test-table tbody tr:last-child {
    border-bottom: none;
  }

  .test-table td {
    padding: 0.625rem 1rem;
    font-size: 0.875rem;
    vertical-align: top;
  }

  .test-name {
    font-weight: 500;
    color: #111827;
    text-align: left;
  }

  .test-date {
    color: #6b7280;
    font-size: 0.875rem;
    text-align: center;
  }

  .test-value {
    text-align: right;
    font-weight: 600;
    color: #111827;
    white-space: nowrap;
  }

  .test-value.high,
  .test-value.low {
    color: #dc2626;
  }

  .test-unit {
    text-align: left;
    color: #6b7280;
    padding-left: 0.25rem;
  }

  .test-range {
    color: #6b7280;
    font-size: 0.875rem;
    text-align: center;
  }

  .test-flag {
    text-align: center;
    font-weight: 600;
  }

  .flag-indicator {
    display: inline-block;
    padding: 0.125rem 0.375rem;
    border-radius: 4px;
    font-size: 0.75rem;
    font-weight: 600;
  }

  .flag-indicator.h,
  .flag-indicator.l {
    background: #fef2f2;
    color: #dc2626;
  }

  /* Notes accordion */
  .notes-section {
    border-top: 1px solid #e5e7eb;
    margin: 0;
  }

  .notes-toggle {
    display: flex;
    justify-content: space-between;
    align-items: center;
    width: 100%;
    padding: 0.75rem 1rem;
    background: #fafafa;
    border: none;
    cursor: pointer;
    font-size: 0.875rem;
    color: #6b7280;
    text-align: left;
    transition: background 0.2s;
  }

  .notes-toggle:hover {
    background: #f3f4f6;
  }

  .notes-toggle-icon {
    transition: transform 0.2s;
  }

  .notes-toggle.expanded .notes-toggle-icon {
    transform: rotate(180deg);
  }

  .notes-content {
    padding: 0.75rem 1rem;
    font-size: 0.813rem;
    color: #6b7280;
    line-height: 1.5;
    background: #fafafa;
    display: none;
    text-align: left;
  }

  .notes-content.expanded {
    display: block;
  }

  .note-item {
    margin-bottom: 0.5rem;
  }

  .note-item:last-child {
    margin-bottom: 0;
  }

  /* Results summary */
  .results-summary {
    background: white;
    border: 1px solid #d1d5db;
    border-radius: 8px;
    padding: 1.5rem;
    margin-bottom: 1.5rem;
    display: flex;
    justify-content: space-around;
    text-align: center;
  }

  .summary-item {
    display: flex;
    flex-direction: column;
  }

  .summary-value {
    font-size: 1.5rem;
    font-weight: 700;
    color: #111827;
  }

  .summary-label {
    font-size: 0.875rem;
    color: #6b7280;
    margin-top: 0.25rem;
  }

  /* Actions */
  .results-actions {
    margin-top: 2rem;
    display: flex;
    justify-content: center;
    gap: 1rem;
    padding: 0 1rem 5rem 1rem; /* Added 5rem bottom padding */
  }

  /* Error and empty states */
  .error-message {
    padding: 1.5rem;
    background: #fef2f2;
    border: 1px solid #fecaca;
    border-radius: 8px;
    color: #991b1b;
    margin-bottom: 1rem;
    text-align: center;
  }

  .no-results {
    text-align: center;
    color: #6b7280;
    padding: 3rem;
    font-size: 1rem;
  }

  .hidden {
    display: none;
  }

  /* Mobile responsiveness */
  @media (max-width: 640px) {
    .results-container {
      margin-top: 2rem;
    }

    .lab-info-grid {
      grid-template-columns: 1fr;
    }

    .test-table {
      font-size: 0.75rem;
    }

    .test-table th,
    .test-table td {
      padding: 0.5rem 0.75rem;
    }

    .results-summary {
      flex-direction: column;
      gap: 1rem;
    }
  }
</style>

<script is:inline define:vars={{ id }}>
  function initResultsTable(id) {
    const container = document.getElementById(id);
    const content = document.getElementById(`${id}-content`);
    const exportBtn = document.getElementById(`${id}-export`);
    
    if (!container || !content || !exportBtn) return;

    let currentResults = null;

    // Listen for lab results
    window.addEventListener('lab-results', (event) => {
      const data = event.detail;
      currentResults = data;
      displayResults(data);
      container.classList.remove('hidden');
    });

    exportBtn.addEventListener('click', () => {
      if (!currentResults) return;
      exportToCSV(currentResults);
    });

    function displayResults(data) {
      if (!data) {
        content.innerHTML = '<div class="no-results">No data received</div>';
        return;
      }

      // Handle errors
      if (data.error) {
        content.innerHTML = `<div class="error-message"><strong>Error:</strong> ${data.error}</div>`;
        return;
      }

      console.log('Received data structure:', JSON.stringify(data, null, 2));

      // Check for aggregated results structure
      if (data.combined_results && data.combined_results.length > 0) {
        displayAggregatedResults(data);
        return;
      }

      // Fallback to file-by-file display if not aggregated
      if (data.file_results) {
        displayFileResults(data.file_results);
        return;
      }

      content.innerHTML = '<div class="no-results">No results found. Please try uploading your lab files again.</div>';
    }

    function displayAggregatedResults(data) {
      let html = '';

      // Display summary if available
      if (data.lab_info) {
        // Count total unique tests and total results across all files
        const uniqueTests = new Set();
        let totalResults = 0;
        
        data.combined_results.forEach(fileData => {
          if (fileData.results && Array.isArray(fileData.results)) {
            fileData.results.forEach(categoryGroup => {
              if (categoryGroup.tests) {
                categoryGroup.tests.forEach(test => {
                  if (test.name) {
                    uniqueTests.add(test.name);
                    totalResults++;
                  }
                });
              }
            });
          }
        });

        html += `
          <div class="results-summary">
            <div class="summary-item">
              <div class="summary-value">${data.lab_info.total_files || 0}</div>
              <div class="summary-label">Files Processed</div>
            </div>
            <div class="summary-item">
              <div class="summary-value">${data.lab_info.successful_files || 0}</div>
              <div class="summary-label">Successful</div>
            </div>
            <div class="summary-item">
              <div class="summary-value">${uniqueTests.size}</div>
              <div class="summary-label">Tests</div>
            </div>
            <div class="summary-item">
              <div class="summary-value">${totalResults}</div>
              <div class="summary-label">Results</div>
            </div>
          </div>
        `;
      }

      // Aggregate tests by category across all files
      const aggregatedCategories = {};
      
      data.combined_results.forEach((fileData) => {
        if (fileData.results && Array.isArray(fileData.results)) {
          fileData.results.forEach((categoryGroup) => {
            if (!categoryGroup.tests || categoryGroup.tests.length === 0) return;
            
            const categoryName = categoryGroup.category || 'Test Results';
            
            if (!aggregatedCategories[categoryName]) {
              aggregatedCategories[categoryName] = [];
            }
            
            // Add tests with date information
            categoryGroup.tests.forEach(test => {
              aggregatedCategories[categoryName].push({
                ...test,
                date_collected: fileData.lab_info?.date_collected || ''
              });
            });
          });
        }
      });

      // Create cards for each aggregated category
      Object.entries(aggregatedCategories).forEach(([categoryName, tests], catIndex) => {
        // Sort tests by name first, then by date (ascending - oldest first)
        tests.sort((a, b) => {
          const nameCompare = (a.name || '').localeCompare(b.name || '');
          if (nameCompare !== 0) return nameCompare;
          
          // Parse dates for proper chronological sorting
          const dateA = a.date_collected ? new Date(a.date_collected.split(' ')[0]) : new Date(0);
          const dateB = b.date_collected ? new Date(b.date_collected.split(' ')[0]) : new Date(0);
          return dateA - dateB; // Ascending order (oldest to newest)
        });
        
        const cardId = `card-${catIndex}`;
        
        // Collect all notes for this category
        const notesArray = [];
        tests.forEach(test => {
          if (test.notes && test.notes.trim()) {
            notesArray.push({
              testName: test.name,
              date: test.date_collected,
              note: test.notes
            });
          }
        });
        
        html += `
          <div class="card">
            <div class="card-header">
              ${categoryName}
            </div>
            <div class="card-body">
              <table class="table table-zebra test-table">
                <thead>
                  <tr>
                    <th>Test</th>
                    <th class="date-header">Date</th>
                    <th class="value-header">Result</th>
                    <th>Unit</th>
                    <th class="range-header">Reference Range</th>
                    <th class="flag-header">Flag</th>
                  </tr>
                </thead>
                <tbody>
                  ${tests.map(test => {
                    const flag = test.flag ? test.flag.toLowerCase() : '';
                    const valueClass = (flag === 'h' || flag === 'high') ? 'high' : ((flag === 'l' || flag === 'low') ? 'low' : '');
                    const flagClass = (flag === 'h' || flag === 'high') ? 'h' : ((flag === 'l' || flag === 'low') ? 'l' : '');
                    
                    // Format date to remove time
                    const formatDate = (dateStr) => {
                      if (!dateStr) return '-';
                      const date = dateStr.split(' ')[0];
                      return date || dateStr;
                    };
                    
                    return `
                      <tr>
                        <td class="test-name">${test.name || 'Unknown Test'}</td>
                        <td class="test-date">${formatDate(test.date_collected)}</td>
                        <td class="test-value ${valueClass}">
                          ${test.value || '-'}
                        </td>
                        <td class="test-unit">${test.unit || ''}</td>
                        <td class="test-range">${test.reference_range || '-'}</td>
                        <td class="test-flag">
                          ${test.flag ? `<span class="flag-indicator ${flagClass}">${test.flag}</span>` : '-'}
                        </td>
                      </tr>
                    `;
                  }).join('')}
                </tbody>
              </table>
              ${notesArray.length > 0 ? `
                <div class="notes-section">
                  <button class="notes-toggle" onclick="toggleNotes('${cardId}')">
                    <span>Notes (${notesArray.length})</span>
                    <span class="notes-toggle-icon">▼</span>
                  </button>
                  <div id="${cardId}-notes" class="notes-content">
                    ${notesArray.map(item => `
                      <div class="note-item">
                        ${item.testName ? `<strong>${item.testName}${item.date ? ` (${item.date})` : ''}:</strong> ` : ''}${item.note}
                      </div>
                    `).join('')}
                  </div>
                </div>
              ` : ''}
            </div>
          </div>
        `;
      });

      // Add processing time if available
      if (data.processing_time) {
        html += `
          <div style="text-align: center; color: #6b7280; font-size: 0.875rem; margin-top: 1rem;">
            Processed in ${(data.processing_time / 1000).toFixed(1)} seconds
          </div>
        `;
      }

      content.innerHTML = html;
    }

    function displayFileResults(fileResults) {
      let html = '';

      fileResults.forEach((file, fileIndex) => {
        if (!file.success) {
          html += `<div class="error-message">
            <strong>${file.filename}</strong> - Failed: ${file.error || 'Unknown error'}
          </div>`;
          return;
        }

        if (file.data) {
          // Process each file's data similar to aggregated results
          const fileData = file.data;
          
          // Lab Info Card
          if (fileData.lab_info && Object.keys(fileData.lab_info).some(key => fileData.lab_info[key])) {
            html += `
              <div class="card">
                <div class="card-header">
                  Lab Information - ${file.filename}
                </div>
                <div class="card-body">
                  <div class="lab-info-grid">
                    ${Object.entries(fileData.lab_info).map(([key, value]) => {
                      if (!value) return '';
                      const label = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                      return `
                        <div class="lab-info-item">
                          <div class="lab-info-label">${label}</div>
                          <div class="lab-info-value">${value}</div>
                        </div>
                      `;
                    }).join('')}
                  </div>
                </div>
              </div>
            `;
          }

          // Test Results
          if (fileData.results && Array.isArray(fileData.results)) {
            fileData.results.forEach((categoryGroup, catIndex) => {
              if (!categoryGroup.tests || categoryGroup.tests.length === 0) return;
              
              const cardId = `file-${fileIndex}-cat-${catIndex}`;
              html += createCategoryCard(categoryGroup, file.filename, cardId);
            });
          }
        }
      });

      content.innerHTML = html || '<div class="no-results">No valid results to display</div>';
    }

    function createCategoryCard(categoryGroup, filename, cardId) {
      const categoryName = categoryGroup.category || 'Test Results';
      
      // Collect notes
      const notesArray = [];
      categoryGroup.tests.forEach(test => {
        if (test.notes && test.notes.trim()) {
          notesArray.push({
            testName: test.name,
            note: test.notes
          });
        }
      });
      
      return `
        <div class="card">
          <div class="card-header">
            ${categoryName} - ${filename}
          </div>
          <div class="card-body">
            <table class="test-table">
              <thead>
                <tr>
                  <th>Test Name</th>
                  <th class="value-header">Result</th>
                  <th>Unit</th>
                  <th>Reference Range</th>
                  <th class="flag-header">Flag</th>
                </tr>
              </thead>
              <tbody>
                ${categoryGroup.tests.map(test => {
                  const flag = test.flag ? test.flag.toLowerCase() : '';
                  const valueClass = flag === 'h' ? 'high' : (flag === 'l' ? 'low' : '');
                  
                  return `
                    <tr>
                      <td class="test-name">${test.name || 'Unknown Test'}</td>
                      <td class="test-value ${valueClass}">
                        ${test.value || '-'}
                      </td>
                      <td class="test-unit">${test.unit || ''}</td>
                      <td class="test-range">${test.reference_range || '-'}</td>
                      <td class="test-flag">
                        ${test.flag ? `<span class="flag-indicator ${flag}">${test.flag}</span>` : '-'}
                      </td>
                    </tr>
                  `;
                }).join('')}
              </tbody>
            </table>
            ${notesArray.length > 0 ? `
              <div class="notes-section">
                <button class="notes-toggle" onclick="toggleNotes('${cardId}')">
                  <span>Notes (${notesArray.length})</span>
                  <span class="notes-toggle-icon">▼</span>
                </button>
                <div id="${cardId}-notes" class="notes-content">
                  ${notesArray.map(item => `
                    <div class="note-item">
                      ${item.testName ? `<strong>${item.testName}:</strong> ` : ''}${item.note}
                    </div>
                  `).join('')}
                </div>
              </div>
            ` : ''}
          </div>
        </div>
      `;
    }

    // Global toggle function for notes
    window.toggleNotes = function(cardId) {
      const notesContent = document.getElementById(`${cardId}-notes`);
      const toggleBtn = notesContent?.previousElementSibling;
      
      if (notesContent && toggleBtn) {
        notesContent.classList.toggle('expanded');
        toggleBtn.classList.toggle('expanded');
      }
    };

    function exportToCSV(data) {
      const rows = [['Source File', 'Category', 'Test Name', 'Result', 'Unit', 'Reference Range', 'Flag', 'Notes']];
      
      // Export aggregated results
      if (data.combined_results) {
        data.combined_results.forEach(fileData => {
          const sourceFile = fileData.source_file || 'Unknown';
          
          if (fileData.results && Array.isArray(fileData.results)) {
            fileData.results.forEach(categoryGroup => {
              const category = categoryGroup.category || 'Uncategorized';
              
              if (categoryGroup.tests) {
                categoryGroup.tests.forEach(test => {
                  rows.push([
                    sourceFile,
                    category,
                    test.name || '',
                    test.value || '',
                    test.unit || '',
                    test.reference_range || '',
                    test.flag || '',
                    test.notes || ''
                  ]);
                });
              }
            });
          }
        });
      }
      
      // Export file results
      else if (data.file_results) {
        data.file_results.forEach(file => {
          if (file.success && file.data && file.data.results) {
            file.data.results.forEach(categoryGroup => {
              const category = categoryGroup.category || 'Uncategorized';
              
              if (categoryGroup.tests) {
                categoryGroup.tests.forEach(test => {
                  rows.push([
                    file.filename,
                    category,
                    test.name || '',
                    test.value || '',
                    test.unit || '',
                    test.reference_range || '',
                    test.flag || '',
                    test.notes || ''
                  ]);
                });
              }
            });
          }
        });
      }

      const csv = rows.map(row => row.map(cell => `"${String(cell).replace(/"/g, '""')}"`).join(',')).join('\n');
      const blob = new Blob([csv], { type: 'text/csv' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `lab-results-${new Date().toISOString().split('T')[0]}.csv`;
      a.click();
      URL.revokeObjectURL(url);
    }
  }

  document.addEventListener('DOMContentLoaded', () => {
    initResultsTable(id);
  });
</script>