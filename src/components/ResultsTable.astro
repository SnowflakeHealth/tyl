---
export interface Props {
  id?: string;
}

const { id = 'results-table' } = Astro.props;
---

<div id={id} class="results-container hidden">
  <div id={`${id}-content`} class="results-content">
    <!-- Results will be dynamically inserted here -->
  </div>

  <div class="results-actions">
    <button id={`${id}-export`} class="btn btn-primary" type="button">
      Export to CSV
    </button>
  </div>
</div>

<style is:global>
  .results-container {
    margin-top: 3rem;
    padding: 0;
    max-width: 1200px;
    margin-left: auto;
    margin-right: auto;
  }

  .results-content {
    min-height: 200px;
    padding: 0 1rem;
  }

  /* Card styles */
  .card {
    background: white;
    border: 1px solid #d1d5db;
    border-radius: 8px;
    margin-bottom: 1.5rem;
    overflow: hidden;
  }

  .card-header {
    padding: 1rem 1.25rem;
    background: #1a1a1a;
    border-bottom: 1px solid #e5e7eb;
    font-weight: 600;
    font-size: 0.875rem;
    color: white;
    text-align: center;
    text-transform: uppercase;
    letter-spacing: 0.05em;
  }

  .card-body {
    padding: 0;
  }

  /* Lab info styles */
  .lab-info-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
    gap: 0;
    padding: 1rem 1.25rem;
  }

  .lab-info-item {
    display: flex;
    justify-content: space-between;
    padding: 0.5rem 0;
    border-bottom: 1px solid #f3f4f6;
  }

  .lab-info-label {
    font-size: 0.875rem;
    color: #6b7280;
    font-weight: 500;
  }

  .lab-info-value {
    font-size: 0.875rem;
    color: #111827;
    font-weight: 600;
    text-align: right;
  }

  /* Test table styles */
  .test-table {
    width: 100%;
    border-collapse: collapse;
  }

  .test-table thead {
    background: #f3f4f6;
  }

  .test-table thead tr {
    background: #f3f4f6;
  }

  .test-table th {
    text-align: left;
    padding: 0.75rem 1rem;
    font-weight: 600;
    font-size: 0.75rem;
    color: #374151;
    border-bottom: 1px solid #e5e7eb;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    background: #f3f4f6;
  }

  .test-table th.value-header {
    text-align: right;
  }

  .test-table th.date-header,
  .test-table th.flag-header {
    text-align: center;
  }

  .test-table th.range-header {
    text-align: center;
  }

  .test-table tbody tr {
    border-bottom: 1px solid #f3f4f6;
  }

  .test-table tbody tr:last-child {
    border-bottom: none;
  }

  .test-table td {
    padding: 0.625rem 1rem;
    font-size: 0.875rem;
    vertical-align: top;
  }

  .test-name {
    font-weight: 500;
    color: #111827;
    text-align: left;
  }

  .test-date {
    color: #6b7280;
    font-size: 0.875rem;
    text-align: center;
  }

  .test-value {
    text-align: right;
    font-weight: 600;
    color: #111827;
    white-space: nowrap;
  }

  .test-value.high,
  .test-value.low {
    color: #dc2626;
  }

  .test-unit {
    text-align: left;
    color: #6b7280;
    padding-left: 0.25rem;
  }

  .test-range {
    color: #6b7280;
    font-size: 0.875rem;
    text-align: center;
  }

  .test-flag {
    text-align: center;
    font-weight: 600;
  }

  .flag-indicator {
    display: inline-block;
    padding: 0.125rem 0.375rem;
    border-radius: 4px;
    font-size: 0.75rem;
    font-weight: 600;
  }

  .flag-indicator.h,
  .flag-indicator.l {
    background: #fef2f2;
    color: #dc2626;
  }

  /* Notes accordion */
  .notes-section {
    border-top: 1px solid #e5e7eb;
    margin: 0;
  }

  .notes-toggle {
    display: flex;
    justify-content: space-between;
    align-items: center;
    width: 100%;
    padding: 0.75rem 1rem;
    background: #fafafa;
    border: none;
    cursor: pointer;
    font-size: 0.875rem;
    color: #6b7280;
    text-align: left;
    transition: background 0.2s;
  }

  .notes-toggle:hover {
    background: #f3f4f6;
  }

  .notes-toggle-icon {
    transition: transform 0.2s;
  }

  .notes-toggle.expanded .notes-toggle-icon {
    transform: rotate(180deg);
  }

  .notes-content {
    padding: 0.75rem 1rem;
    font-size: 0.813rem;
    color: #6b7280;
    line-height: 1.5;
    background: #fafafa;
    display: none;
    text-align: left;
  }

  .notes-content.expanded {
    display: block;
  }

  .note-item {
    margin-bottom: 0.5rem;
  }

  .note-item:last-child {
    margin-bottom: 0;
  }

  /* Results summary */
  .results-summary {
    background: white;
    border: 1px solid #d1d5db;
    border-radius: 8px;
    padding: 1.5rem;
    margin-bottom: 1.5rem;
    display: flex;
    justify-content: space-around;
    text-align: center;
  }

  .summary-item {
    display: flex;
    flex-direction: column;
  }

  .summary-value {
    font-size: 1.5rem;
    font-weight: 700;
    color: #111827;
  }

  .summary-label {
    font-size: 0.875rem;
    color: #6b7280;
    margin-top: 0.25rem;
  }

  /* Actions */
  .results-actions {
    margin-top: 2rem;
    display: flex;
    justify-content: center;
    gap: 1rem;
    padding: 0 1rem 5rem 1rem; /* Added 5rem bottom padding */
  }

  /* Error and empty states */
  .error-message {
    padding: 1.5rem;
    background: #fef2f2;
    border: 1px solid #fecaca;
    border-radius: 8px;
    color: #991b1b;
    margin-bottom: 1rem;
    text-align: center;
  }

  .no-results {
    text-align: center;
    color: #6b7280;
    padding: 3rem;
    font-size: 1rem;
  }

  .hidden {
    display: none;
  }

  /* Test group visual indicators - IBM Design Library colorblind-safe palette */
  .test-group-0 td:first-child {
    border-left: 3px solid #6094eb; /* Blue - R:96 G:148 B:235 */
    padding-left: 1rem;
  }
  
  .test-group-1 td:first-child {
    border-left: 3px solid #8a5ed6; /* Purple - R:138 G:94 B:214 */
    padding-left: 1rem;
  }
  
  .test-group-2 td:first-child {
    border-left: 3px solid #d74a87; /* Pink/Magenta - R:215 G:74 B:135 */
    padding-left: 1rem;
  }
  
  .test-group-3 td:first-child {
    border-left: 3px solid #ee7836; /* Orange - R:238 G:120 B:54 */
    padding-left: 1rem;
  }
  
  .test-group-4 td:first-child {
    border-left: 3px solid #f0cc3e; /* Yellow - R:240 G:204 B:62 */
    padding-left: 1rem;
  }
  
  /* Bold the first row (most recent) of each test group */
  .test-group-first td.test-name {
    font-weight: 600;
  }
  
  /* Make non-first rows in a group have lighter text */
  .test-table tbody tr:not(.test-group-first) td {
    color: #6b7280; /* gray-500 */
  }
  
  /* Keep flag colors consistent even in secondary rows */
  .test-table tbody tr:not(.test-group-first) .test-value.high,
  .test-table tbody tr:not(.test-group-first) .test-value.low {
    color: #dc2626; /* Keep red for high/low values */
  }

  /* Mobile responsiveness */
  @media (max-width: 640px) {
    .results-container {
      margin-top: 2rem;
    }

    .lab-info-grid {
      grid-template-columns: 1fr;
    }

    .test-table {
      font-size: 0.75rem;
    }

    .test-table th,
    .test-table td {
      padding: 0.5rem 0.75rem;
    }

    .results-summary {
      flex-direction: column;
      gap: 1rem;
    }
  }
</style>

<script is:inline define:vars={{ id }}>
  function initResultsTable(id) {
    const container = document.getElementById(id);
    const content = document.getElementById(`${id}-content`);
    const exportBtn = document.getElementById(`${id}-export`);
    
    if (!container || !content || !exportBtn) return;

    let currentResults = null;

    // Listen for lab results
    window.addEventListener('lab-results', async (event) => {
      const data = event.detail;
      currentResults = data;
      displayResults(data);
      container.classList.remove('hidden');
      
      // Track that results were displayed (only once per session)
      const sessionKey = 'results_tracked_' + Date.now();
      if (!sessionStorage.getItem(sessionKey)) {
        sessionStorage.setItem(sessionKey, 'true');
        try {
          await fetch('/api/metrics', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ 
              metric: 'total_results_displayed',
              increment: 1 
            })
          });
          console.log('Results display tracked');
        } catch (error) {
          // Don't interrupt user experience if metrics fail
          console.error('Failed to track metrics:', error);
        }
      }
    });

    exportBtn.addEventListener('click', () => {
      if (!currentResults) return;
      exportToCSV(currentResults);
    });

    function escapeHtml(unsafe) {
      if (unsafe == null) return '';
      return String(unsafe)
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#039;");
    }

    function displayResults(data) {
      if (!data) {
        content.innerHTML = '<div class="no-results">No data received</div>';
        return;
      }

      // Handle errors
      if (data.error) {
        content.innerHTML = `<div class="error-message"><strong>Error:</strong> ${escapeHtml(data.error)}</div>`;
        return;
      }

      console.log('Received data structure:', JSON.stringify(data, null, 2));

      // Check for aggregated results structure
      if (data.combined_results && data.combined_results.length > 0) {
        displayAggregatedResults(data);
        return;
      }

      // No longer using file_results - all data is in combined_results

      content.innerHTML = '<div class="no-results">No results found. Please try uploading your lab files again.</div>';
    }

    function displayAggregatedResults(data) {
      let html = '';

      // Display summary if available
      if (data.lab_info) {
        // Count total unique tests and total results across all files
        const uniqueTests = new Set();
        const uniqueNormalizedTests = new Set();
        let totalResults = 0;
        
        data.combined_results.forEach(fileData => {
          // Handle results structure (from extraction)
          if (fileData.results && Array.isArray(fileData.results)) {
            fileData.results.forEach(category => {
              if (category.tests) {
                category.tests.forEach(test => {
                  if (test.name) {
                    uniqueTests.add(test.name);
                    if (test.normalized_name) {
                      uniqueNormalizedTests.add(test.normalized_name);
                    }
                    totalResults++;
                  }
                });
              }
            });
          }
        });

        html += `
          <div class="results-summary">
            <div class="summary-item">
              <div class="summary-value">${data.lab_info.total_files || 0}</div>
              <div class="summary-label">Files Processed</div>
            </div>
            <div class="summary-item">
              <div class="summary-value">${data.lab_info.successful_files || 0}</div>
              <div class="summary-label">Successful</div>
            </div>
            <div class="summary-item">
              <div class="summary-value">${uniqueTests.size}</div>
              <div class="summary-label">Tests</div>
            </div>
            <div class="summary-item">
              <div class="summary-value">${totalResults}</div>
              <div class="summary-label">Results</div>
            </div>
          </div>
        `;
      }

      // Aggregate tests by normalized category across all files
      const aggregatedByCategory = {};
      
      data.combined_results.forEach((fileData) => {
        if (fileData.results && Array.isArray(fileData.results)) {
          fileData.results.forEach((category) => {
            if (!category.tests || category.tests.length === 0) return;
            
            // Group tests by their normalized category
            category.tests.forEach(test => {
              // Use normalized_category if available, otherwise fall back to original category
              const normalizedCat = test.normalized_category || category.category || 'Other';
              
              if (!aggregatedByCategory[normalizedCat]) {
                aggregatedByCategory[normalizedCat] = {
                  displayName: normalizedCat,
                  tests: []
                };
              }
              
              // Add test with its date
              aggregatedByCategory[normalizedCat].tests.push({
                name: test.name,
                normalized_name: test.normalized_name || test.name,
                value: test.value || '-',
                unit: test.unit || '',
                reference_range: test.reference_range || '-',
                flag: test.flag || '',
                notes: test.notes || '',
                date: fileData.lab_info?.date_collected || fileData.lab_info?.date_reported || '',
                source_file: fileData.source_file || 'Unknown'
              });
            });
          });
        }
      });

      // Define category order for better user experience (matching the backend categories)
      const categoryOrder = [
        'Blood',
        'Metabolic',
        'Heart',
        'Electrolytes',
        'Kidney',
        'Liver',
        'Pancreas',
        'Thyroid',
        'Nutrients',
        'Male Health',
        'Immune Regulation',
        'Autoimmunity',
        'Stress & Aging',
        'Biological Age',
        'Environmental Toxins',
        'Urine',
        'Other'
      ];
      
      // Sort categories by defined order
      const sortedCategories = Object.entries(aggregatedByCategory).sort((a, b) => {
        const indexA = categoryOrder.indexOf(a[0]);
        const indexB = categoryOrder.indexOf(b[0]);
        
        // If both are in the order list, sort by that order
        if (indexA !== -1 && indexB !== -1) {
          return indexA - indexB;
        }
        // If only one is in the order list, it comes first
        if (indexA !== -1) return -1;
        if (indexB !== -1) return 1;
        // Otherwise, sort alphabetically
        return a[0].localeCompare(b[0]);
      });
      
      // Create cards grouped by category
      sortedCategories.forEach(([_, categoryData], catIndex) => {
        // Sort tests first by normalized name, then by date (descending)
        categoryData.tests.sort((a, b) => {
          // First sort by normalized name
          const nameCompare = (a.normalized_name || a.name).localeCompare(b.normalized_name || b.name);
          if (nameCompare !== 0) return nameCompare;
          
          // Then sort by date (descending - newest first)
          const dateA = a.date ? new Date(a.date.split(' ')[0]) : new Date(0);
          const dateB = b.date ? new Date(b.date.split(' ')[0]) : new Date(0);
          return dateB - dateA;
        });
        
        const cardId = `card-${catIndex}`;
        
        html += `
          <div class="card">
            <div class="card-header">
              ${escapeHtml(categoryData.displayName)}
            </div>
            <div class="card-body">
              <table class="table table-zebra test-table">
                <thead>
                  <tr>
                    <th>Test</th>
                    <th class="value-header">Result</th>
                    <th>Unit</th>
                    <th class="range-header">Reference Range</th>
                    <th class="flag-header">Flag</th>
                    <th class="date-header">Date</th>
                  </tr>
                </thead>
                <tbody>
                  ${(() => {
                    let currentTestName = '';
                    let testGroupIndex = -1;
                    let isFirstInGroup = true;
                    
                    return categoryData.tests.map(test => {
                      const flag = test.flag ? test.flag.toLowerCase() : '';
                      const valueClass = (flag === 'h' || flag === 'high') ? 'high' : ((flag === 'l' || flag === 'low') ? 'low' : '');
                      const flagClass = (flag === 'h' || flag === 'high') ? 'h' : ((flag === 'l' || flag === 'low') ? 'l' : '');
                      
                      // Check if this is a new test group
                      const testName = test.normalized_name || test.name;
                      if (testName !== currentTestName) {
                        currentTestName = testName;
                        testGroupIndex = (testGroupIndex + 1) % 5; // Cycle through 0-4 (5 colors)
                        isFirstInGroup = true;
                      } else {
                        isFirstInGroup = false;
                      }
                      
                      // Format date to remove time
                      const formatDate = (dateStr) => {
                        if (!dateStr) return '-';
                        const date = dateStr.split(' ')[0];
                        return date || dateStr;
                      };
                      
                      // Build class list for the row
                      const rowClasses = [`test-group-${testGroupIndex}`];
                      if (isFirstInGroup) {
                        rowClasses.push('test-group-first');
                      }
                      
                      return `
                        <tr class="${rowClasses.join(' ')}">
                          <td class="test-name">${escapeHtml(test.normalized_name || '')}</td>
                          <td class="test-value ${valueClass}">
                            ${escapeHtml(test.value || '-')}
                          </td>
                          <td class="test-unit">${escapeHtml(test.unit || '')}</td>
                          <td class="test-range">${escapeHtml(test.reference_range || '-')}</td>
                          <td class="test-flag">
                            ${test.flag ? `<span class="flag-indicator ${flagClass}">${escapeHtml(test.flag)}</span>` : '-'}
                          </td>
                          <td class="test-date">${escapeHtml(formatDate(test.date))}</td>
                        </tr>
                      `;
                    }).join('');
                  })()}
                </tbody>
              </table>
              ${(() => {
                // Collect test-specific notes grouped by test name
                const notesByTest = {};
                
                // Group notes by unique test name
                categoryData.tests.forEach(test => {
                  if (test.notes && test.notes.trim()) {
                    const testName = test.normalized_name || test.name;
                    if (!notesByTest[testName]) {
                      notesByTest[testName] = new Set();
                    }
                    // Use Set to automatically handle duplicates
                    notesByTest[testName].add(test.notes);
                  }
                });
                
                // Count total unique notes
                const totalNotesCount = Object.values(notesByTest).reduce((sum, notesSet) => sum + notesSet.size, 0);
                
                // Only show notes section if there are test-specific notes
                if (totalNotesCount > 0) {
                  return `
                    <div class="notes-section">
                      <button class="notes-toggle" onclick="toggleNotes('${cardId}')">
                        <span>Notes (${totalNotesCount})</span>
                        <span class="notes-toggle-icon">▼</span>
                      </button>
                      <div id="${cardId}-notes" class="notes-content">
                        ${Object.entries(notesByTest).map(([testName, notesSet]) => {
                          const notesArray = Array.from(notesSet);
                          return `
                            <div class="note-item">
                              <strong>${escapeHtml(testName)}</strong>
                              <div style="margin-left: 1rem; margin-top: 0.25rem;">
                                ${notesArray.map(note => escapeHtml(note)).join('<br>')}
                              </div>
                            </div>
                          `;
                        }).join('')}
                      </div>
                    </div>
                  `;
                }
                return '';
              })()}
            </div>
          </div>
        `;
      });

      // Add processing time if available
      if (data.processing_time) {
        html += `
          <div style="text-align: center; color: #6b7280; font-size: 0.875rem; margin-top: 1rem;">
            Processed in ${(data.processing_time / 1000).toFixed(1)} seconds
          </div>
        `;
      }

      content.innerHTML = html;
    }

    // Global toggle function for notes
    window.toggleNotes = function(cardId) {
      const notesContent = document.getElementById(`${cardId}-notes`);
      const toggleBtn = notesContent?.previousElementSibling;
      
      if (notesContent && toggleBtn) {
        notesContent.classList.toggle('expanded');
        toggleBtn.classList.toggle('expanded');
      }
    };

    function exportToCSV(data) {
      const rows = [['Source File', 'Date', 'Original Category', 'Normalized Category', 'Test Name', 'Normalized Name', 'Result', 'Unit', 'Reference Range', 'Flag', 'Notes']];
      
      // Export aggregated results with all fields
      if (data.combined_results) {
        data.combined_results.forEach(fileData => {
          const sourceFile = fileData.source_file || 'Unknown';
          
          if (fileData.results && Array.isArray(fileData.results)) {
            fileData.results.forEach(category => {
              const categoryName = category.category || 'Uncategorized';
              const testDate = fileData.lab_info?.date_collected || fileData.lab_info?.date_reported || '';
              
              if (category.tests) {
                category.tests.forEach(test => {
                  rows.push([
                    sourceFile,
                    testDate,
                    categoryName,
                    test.normalized_category || '',
                    test.name || '',
                    test.normalized_name || '',
                    test.value || '',
                    test.unit || '',
                    test.reference_range || '',
                    test.flag || '',
                    test.notes || ''
                  ]);
                });
              }
            });
          }
        });
      }

      const csv = rows.map(row => row.map(cell => `"${String(cell).replace(/"/g, '""')}"`).join(',')).join('\n');
      const blob = new Blob([csv], { type: 'text/csv' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `lab-results-${new Date().toISOString().split('T')[0]}.csv`;
      a.click();
      URL.revokeObjectURL(url);
    }
  }

  document.addEventListener('DOMContentLoaded', () => {
    initResultsTable(id);
  });
</script>