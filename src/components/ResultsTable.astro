---
export interface Props {
  id?: string;
}

const { id = 'results-table' } = Astro.props;
---

<div id={id} class="results-container hidden">
  <div id={`${id}-content`} class="results-content">
    <!-- Results will be dynamically inserted here -->
  </div>

  <div class="results-actions">
    <button id={`${id}-export`} class="btn btn-primary" type="button">
      Export to CSV
    </button>
  </div>
</div>

<style is:global>
  .results-container {
    margin-top: 3rem;
    padding: 0;
    max-width: 1200px;
    margin-left: auto;
    margin-right: auto;
  }

  .results-content {
    min-height: 200px;
    padding: 0 1rem;
  }

  /* Card styles */
  .card {
    background: white;
    border: 1px solid #d1d5db;
    border-radius: 8px;
    margin-bottom: 0;
    margin-top: 1.5rem;
    overflow: hidden;
  }
  
  .card:first-child {
    margin-top: 0;
  }

  .card-header {
    padding: 1rem 1.25rem;
    background: #1a1a1a;
    border-bottom: 1px solid #e5e7eb;
    font-weight: 600;
    font-size: 0.875rem;
    color: white;
    text-align: center;
    text-transform: uppercase;
    letter-spacing: 0.05em;
  }

  .card-body {
    padding: 0;
    margin: 0;
  }

  /* Lab info styles */
  .lab-info-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
    gap: 0;
    padding: 1rem 1.25rem;
  }

  .lab-info-item {
    display: flex;
    justify-content: space-between;
    padding: 0.5rem 0;
    border-bottom: 1px solid #f3f4f6;
  }

  .lab-info-label {
    font-size: 0.875rem;
    color: #6b7280;
    font-weight: 500;
  }

  .lab-info-value {
    font-size: 0.875rem;
    color: #111827;
    font-weight: 600;
    text-align: right;
  }

  /* Test table styles */
  .test-table {
    width: 100%;
    border-collapse: collapse;
    table-layout: fixed;
    margin-bottom: 0 !important;
    margin-top: 0 !important;
  }
  

  .test-table thead {
    background: #f3f4f6;
  }

  .test-table thead tr {
    background: #f3f4f6;
  }

  .test-table th {
    text-align: left;
    padding: 0.75rem 1rem;
    font-weight: 600;
    font-size: 0.75rem;
    color: #374151;
    border-bottom: 1px solid #e5e7eb;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    background: #f3f4f6;
  }

  .test-table th.value-header {
    text-align: right;
  }

  .test-table th.date-header,
  .test-table th.flag-header,
  .test-table th.chart-header {
    text-align: center;
  }

  .test-table th.range-header {
    text-align: center;
  }

  .test-table tbody tr {
    border-bottom: 1px solid #f3f4f6;
  }

  .test-table tbody tr:last-child {
    border-bottom: none;
  }

  .test-table td {
    padding: 0.625rem 1rem;
    font-size: 0.875rem;
    vertical-align: top;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  .test-name {
    font-weight: 500;
    color: #111827;
    text-align: left;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  .test-date {
    color: #6b7280;
    font-size: 0.875rem;
    text-align: center;
  }

  .test-value {
    text-align: right;
    font-weight: 600;
    color: #111827;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  .test-value.high,
  .test-value.low {
    color: #dc2626;
  }

  .test-unit {
    text-align: left;
    color: #6b7280;
    padding-left: 0.25rem;
  }

  .test-range {
    color: #6b7280;
    font-size: 0.875rem;
    text-align: center;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  .test-flag {
    text-align: center;
    font-weight: 600;
    overflow: visible !important;
    text-overflow: clip !important;
  }

  .test-chart {
    text-align: center;
    padding: 0.25rem 0.5rem;
    overflow: visible !important;
    max-width: none;
    text-overflow: clip !important;
  }

  .test-chart svg {
    display: inline-block;
    vertical-align: middle;
  }

  .flag-indicator {
    display: inline-block;
    padding: 0.125rem 0.375rem;
    border-radius: 4px;
    font-size: 0.75rem;
    font-weight: 600;
  }

  .flag-indicator.h,
  .flag-indicator.l {
    background: #fef2f2;
    color: #dc2626;
  }

  /* Notes table - no borders */
  .notes-table {
    margin-top: 0;
    margin-bottom: 0;
  }
  
  .notes-table tbody tr {
    border-bottom: none !important;
  }
  
  .notes-header-row:hover {
    background-color: #f9fafb;
  }
  
  .notes-chevron {
    display: inline-block;
    font-size: 0.75rem;
    color: #6b7280;
    user-select: none;
  }
  
  .notes-detail-row {
    display: none;
  }
  
  .notes-detail-row.show {
    display: table-row;
  }

  .note-item {
    margin-bottom: 0.5rem;
  }

  .note-item:last-child {
    margin-bottom: 0;
  }

  /* Results summary */
  .results-summary {
    background: white;
    border: 1px solid #d1d5db;
    border-radius: 8px;
    padding: 1.5rem;
    margin-bottom: 0;
    display: flex;
    justify-content: space-around;
    text-align: center;
  }

  .summary-item {
    display: flex;
    flex-direction: column;
  }

  .summary-value {
    font-size: 1.5rem;
    font-weight: 700;
    color: #111827;
  }

  .summary-label {
    font-size: 0.875rem;
    color: #6b7280;
    margin-top: 0.25rem;
  }

  /* Privacy notice */
  .privacy-notice {
    margin-top: 0.5rem;
    margin-bottom: 2rem;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 0.375rem;
    font-size: 0.75rem;
    color: #6b7280;
  }

  .privacy-notice svg {
    width: 14px;
    height: 14px;
    flex-shrink: 0;
  }

  /* Actions */
  .results-actions {
    margin-top: 2rem;
    display: flex;
    justify-content: center;
    gap: 1rem;
    padding: 0 1rem 5rem 1rem; /* Added 5rem bottom padding */
  }

  /* Error and empty states */
  .error-message {
    padding: 1.5rem;
    background: #fef2f2;
    border: 1px solid #fecaca;
    border-radius: 8px;
    color: #991b1b;
    margin-bottom: 1rem;
    text-align: center;
  }

  .no-results {
    text-align: center;
    color: #6b7280;
    padding: 3rem;
    font-size: 1rem;
  }

  .hidden {
    display: none;
  }

  /* Simple row borders without zebra striping - medium gray */
  .test-table tbody tr {
    border-bottom: 1px solid #d1d5db;
  }
  
  /* Dashed borders only for collapsed (hidden) rows within the same test group */
  .test-table tbody tr.test-group-collapsed.show {
    border-bottom: 1px dashed #e5e7eb;
  }
  
  /* Dashed border for first row ONLY when it has expanded children visible */
  .test-table tbody tr.test-group-first.test-group-expandable.has-expanded-children {
    border-bottom: 1px dashed #e5e7eb;
  }
  
  /* Keep solid medium border for last row in group and single rows */
  .test-table tbody tr.test-group-last,
  .test-table tbody tr:not(.test-group-collapsed):not(.test-group-expandable) {
    border-bottom: 1px solid #d1d5db;
  }
  
  /* Bold the first row (most recent) of each test group */
  .test-group-first td.test-name {
    font-weight: 600;
  }
  
  /* Make non-first rows in a group have lighter text */
  .test-table tbody tr:not(.test-group-first) td {
    color: #6b7280; /* gray-500 */
  }
  
  /* Keep flag colors consistent even in secondary rows */
  .test-table tbody tr:not(.test-group-first) .test-value.high,
  .test-table tbody tr:not(.test-group-first) .test-value.low {
    color: #dc2626; /* Keep red for high/low values */
  }

  /* Accordion styles */
  .test-group-collapsed {
    display: none;
  }

  .test-group-expandable:hover {
    background-color: #f9fafb;
  }

  .test-group-chevron {
    display: inline-block;
    margin-right: 0.5rem;
    font-size: 0.75rem;
    color: #6b7280;
    user-select: none;
  }
  
  /* Chevron column styling */
  .test-chevron {
    width: 20px;
    text-align: center;
    padding: 0.625rem 0.25rem;
    white-space: nowrap;
    overflow: visible !important;
    text-overflow: clip !important;
  }

  /* Ensure collapsed rows maintain their stripe color when shown */
  .test-group-collapsed.show {
    display: table-row;
  }

  /* Animation for smooth expand/collapse */
  @keyframes slideDown {
    from {
      opacity: 0;
      transform: translateY(-10px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  .test-group-collapsed.show {
    animation: slideDown 0.2s ease;
  }

  /* Responsive design with progressive column hiding */
  
  /* Tablet - hide Reference Range column */
  @media (max-width: 1024px) {
    .test-table th:nth-child(5),
    .test-table td:nth-child(5) {
      display: none;
    }
  }
  
  /* Small Tablet - hide Flag, Unit, and Chart columns */
  @media (max-width: 768px) {
    .results-container {
      margin-top: 2rem;
    }

    .lab-info-grid {
      grid-template-columns: 1fr;
    }

    .test-table {
      font-size: 0.75rem;
    }

    .test-table th,
    .test-table td {
      padding: 0.5rem 0.75rem;
    }
    
    /* Hide Unit column */
    .test-table th:nth-child(4),
    .test-table td:nth-child(4) {
      display: none;
    }
    
    /* Hide Flag column */
    .test-table th:nth-child(6),
    .test-table td:nth-child(6) {
      display: none;
    }
    
    /* Hide Chart column */
    .test-table th:nth-child(8),
    .test-table td:nth-child(8) {
      display: none;
    }

    .results-summary {
      flex-direction: column;
      gap: 1rem;
    }
  }
</style>

<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.9.0/d3.min.js"></script>
<script is:inline define:vars={{ id }}>
  function initResultsTable(id) {
    const container = document.getElementById(id);
    const content = document.getElementById(`${id}-content`);
    const exportBtn = document.getElementById(`${id}-export`);
    
    if (!container || !content || !exportBtn) return;

    let currentResults = null;

    // Listen for lab results
    window.addEventListener('lab-results', async (event) => {
      const data = event.detail;
      currentResults = data;
      displayResults(data);
      container.classList.remove('hidden');
      
      // Scroll to top instantly when results appear
      setTimeout(() => {
        window.scrollTo({ top: 0 });
      }, 100);
      
      // Track that results were displayed (only once per session)
      const sessionKey = 'results_tracked_' + Date.now();
      if (!sessionStorage.getItem(sessionKey)) {
        sessionStorage.setItem(sessionKey, 'true');
        try {
          await fetch('/api/metrics', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ 
              metric: 'total_results_displayed',
              increment: 1 
            })
          });
          console.log('Results display tracked');
        } catch (error) {
          // Don't interrupt user experience if metrics fail
          console.error('Failed to track metrics:', error);
        }
      }
    });

    exportBtn.addEventListener('click', () => {
      if (!currentResults) return;
      exportToCSV(currentResults);
    });

    function escapeHtml(unsafe) {
      if (unsafe == null) return '';
      return String(unsafe)
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#039;");
    }

    function createLabSparkline(data, options = {}) {
      const {
        width = 160,
        height = 30,
        padding = 2,
        flag = null,
        startDate = null,
        endDate = null,
        strokeWidth = 1.5
      } = options;
      
      // Set colors based on flag
      let gradientStart, strokeColor;
      if (flag === 'h' || flag === 'l') {
        gradientStart = '#f85149';
        strokeColor = '#f85149';
      } else {
        gradientStart = '#40c463';
        strokeColor = '#40c463';
      }
      
      // Create SVG container
      const svg = d3.create('svg')
        .attr('width', width)
        .attr('height', height)
        .attr('viewBox', `0 0 ${width} ${height}`);
      
      // Create gradient
      const gradientId = `gradient-${Math.random().toString(36).substring(2, 11)}`;
      const defs = svg.append('defs');
      const gradient = defs.append('linearGradient')
        .attr('id', gradientId)
        .attr('x1', '0%').attr('y1', '0%')
        .attr('x2', '0%').attr('y2', '100%');
      
      gradient.append('stop')
        .attr('offset', '0%')
        .attr('stop-color', gradientStart)
        .attr('stop-opacity', 0.6);
      
      gradient.append('stop')
        .attr('offset', '100%')
        .attr('stop-color', '#ffffff')
        .attr('stop-opacity', 0);
      
      // Set up scales
      let xScale, yScale;
      
      if (startDate && endDate && data[0]?.date) {
        // Time-based scale
        xScale = d3.scaleTime()
          .domain([new Date(startDate), new Date(endDate)])
          .range([padding, width - padding]);
        
        const values = data.map(d => parseFloat(d.value) || 0);
        yScale = d3.scaleLinear()
          .domain([0, d3.max(values)])
          .range([height - padding, padding]);
      } else {
        // Index-based scale for simple arrays
        xScale = d3.scaleLinear()
          .domain([0, data.length - 1])
          .range([padding, width - padding]);
        
        const values = data.map(d => parseFloat(d.value || d) || 0);
        yScale = d3.scaleLinear()
          .domain([0, d3.max(values)])
          .range([height - padding, padding]);
      }
      
      // Line and area generators
      const line = d3.line()
        .x((d, i) => {
          if (startDate && endDate && d.date) {
            return xScale(new Date(d.date));
          }
          return xScale(i);
        })
        .y(d => yScale(parseFloat(d.value || d) || 0))
        .curve(d3.curveCardinal.tension(0.2));
      
      const area = d3.area()
        .x((d, i) => {
          if (startDate && endDate && d.date) {
            return xScale(new Date(d.date));
          }
          return xScale(i);
        })
        .y0(height - padding)
        .y1(d => yScale(parseFloat(d.value || d) || 0))
        .curve(d3.curveCardinal.tension(0.2));
      
      // Draw area and line
      svg.append('path')
        .datum(data)
        .attr('d', area)
        .attr('fill', `url(#${gradientId})`);
      
      svg.append('path')
        .datum(data)
        .attr('d', line)
        .attr('fill', 'none')
        .attr('stroke', strokeColor)
        .attr('stroke-width', strokeWidth)
        .attr('stroke-linecap', 'round');
      
      return svg.node().outerHTML;
    }

    function displayResults(data) {
      if (!data) {
        content.innerHTML = '<div class="no-results">No data received</div>';
        return;
      }

      // Handle errors
      if (data.error) {
        content.innerHTML = `<div class="error-message"><strong>Error:</strong> ${escapeHtml(data.error)}</div>`;
        return;
      }

      console.log('Received data structure:', JSON.stringify(data, null, 2));

      // Check for aggregated results structure
      if (data.combined_results && data.combined_results.length > 0) {
        displayAggregatedResults(data);
        return;
      }

      // No longer using file_results - all data is in combined_results

      content.innerHTML = '<div class="no-results">No results found. Please try uploading your lab files again.</div>';
    }

    function displayAggregatedResults(data) {
      let html = '';
      
      // Calculate global date range across all tests for consistent sparkline scales
      let globalStartDate = null;
      let globalEndDate = null;
      
      data.combined_results.forEach(fileData => {
        const date = fileData.lab_info?.date_collected || fileData.lab_info?.date_reported;
        if (date) {
          const dateObj = new Date(date.split(' ')[0]);
          if (!globalStartDate || dateObj < globalStartDate) {
            globalStartDate = dateObj;
          }
          if (!globalEndDate || dateObj > globalEndDate) {
            globalEndDate = dateObj;
          }
        }
      });

      // Display summary if available
      if (data.lab_info) {
        // Count total unique tests and total results across all files
        const uniqueTests = new Set();
        const uniqueNormalizedTests = new Set();
        let totalResults = 0;
        
        data.combined_results.forEach(fileData => {
          // Handle results structure (from extraction)
          if (fileData.results && Array.isArray(fileData.results)) {
            fileData.results.forEach(category => {
              if (category.tests) {
                category.tests.forEach(test => {
                  if (test.name) {
                    uniqueTests.add(test.name);
                    if (test.normalized_name) {
                      uniqueNormalizedTests.add(test.normalized_name);
                    }
                    totalResults++;
                  }
                });
              }
            });
          }
        });

        html += `
          <div class="results-summary">
            <div class="summary-item">
              <div class="summary-value">${data.lab_info.total_files || 0}</div>
              <div class="summary-label">Files Processed</div>
            </div>
            <div class="summary-item">
              <div class="summary-value">${data.lab_info.successful_files || 0}</div>
              <div class="summary-label">Successful</div>
            </div>
            <div class="summary-item">
              <div class="summary-value">${uniqueTests.size}</div>
              <div class="summary-label">Tests</div>
            </div>
            <div class="summary-item">
              <div class="summary-value">${totalResults}</div>
              <div class="summary-label">Results</div>
            </div>
          </div>
          <div class="privacy-notice">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
              <path stroke-linecap="round" stroke-linejoin="round" d="M16.5 10.5V6.75a4.5 4.5 0 10-9 0v3.75m-.75 11.25h10.5a2.25 2.25 0 002.25-2.25v-6.75a2.25 2.25 0 00-2.25-2.25H6.75a2.25 2.25 0 00-2.25 2.25v6.75a2.25 2.25 0 002.25 2.25z" />
            </svg>
            <span>Your data vanishes when you close or refresh this page • Nothing saved or tracked • Export to keep results</span>
          </div>
        `;
      }

      // Aggregate tests by normalized category across all files
      const aggregatedByCategory = {};
      
      data.combined_results.forEach((fileData) => {
        if (fileData.results && Array.isArray(fileData.results)) {
          fileData.results.forEach((category) => {
            if (!category.tests || category.tests.length === 0) return;
            
            // Group tests by their normalized category
            category.tests.forEach(test => {
              // Use normalized_category if available, otherwise fall back to original category
              const normalizedCat = test.normalized_category || category.category || 'Other';
              
              if (!aggregatedByCategory[normalizedCat]) {
                aggregatedByCategory[normalizedCat] = {
                  displayName: normalizedCat,
                  tests: []
                };
              }
              
              // Add test with its date
              aggregatedByCategory[normalizedCat].tests.push({
                name: test.name,
                normalized_name: test.normalized_name || test.name,
                value: test.value || '-',
                unit: test.unit || '',
                reference_range: test.reference_range || '-',
                flag: test.flag || '',
                notes: test.notes || '',
                date: fileData.lab_info?.date_collected || fileData.lab_info?.date_reported || '',
                source_file: fileData.source_file || 'Unknown'
              });
            });
          });
        }
      });

      // Define category order for better user experience (matching the backend categories)
      const categoryOrder = [
        'Blood',
        'Metabolic',
        'Heart',
        'Electrolytes',
        'Kidney',
        'Liver',
        'Pancreas',
        'Thyroid',
        'Nutrients',
        'Male Health',
        'Immune Regulation',
        'Autoimmunity',
        'Stress & Aging',
        'Biological Age',
        'Environmental Toxins',
        'Urine',
        'Other'
      ];
      
      // Sort categories by defined order
      const sortedCategories = Object.entries(aggregatedByCategory).sort((a, b) => {
        const indexA = categoryOrder.indexOf(a[0]);
        const indexB = categoryOrder.indexOf(b[0]);
        
        // If both are in the order list, sort by that order
        if (indexA !== -1 && indexB !== -1) {
          return indexA - indexB;
        }
        // If only one is in the order list, it comes first
        if (indexA !== -1) return -1;
        if (indexB !== -1) return 1;
        // Otherwise, sort alphabetically
        return a[0].localeCompare(b[0]);
      });
      
      // Create cards grouped by category
      sortedCategories.forEach(([_, categoryData], catIndex) => {
        // Sort tests first by normalized name, then by date (descending)
        categoryData.tests.sort((a, b) => {
          // First sort by normalized name
          const nameCompare = (a.normalized_name || a.name).localeCompare(b.normalized_name || b.name);
          if (nameCompare !== 0) return nameCompare;
          
          // Then sort by date (descending - newest first)
          const dateA = a.date ? new Date(a.date.split(' ')[0]) : new Date(0);
          const dateB = b.date ? new Date(b.date.split(' ')[0]) : new Date(0);
          return dateB - dateA;
        });
        
        const cardId = `card-${catIndex}`;
        
        html += `
          <div class="card">
            <div class="card-header">
              ${escapeHtml(categoryData.displayName)}
            </div>
            <div class="card-body">
              <table class="table test-table">
                <thead>
                  <tr>
                    <th style="width: 30px;"></th>
                    <th style="width: 180px;">Test</th>
                    <th class="value-header" style="width: 90px;">Result</th>
                    <th style="width: 70px;">Unit</th>
                    <th class="range-header" style="width: 140px;">Reference Range</th>
                    <th class="flag-header" style="width: 50px;">Flag</th>
                    <th class="date-header" style="width: 110px;">Date</th>
                    <th class="chart-header" style="width: 180px;">Chart</th>
                  </tr>
                </thead>
                <tbody>
                  ${(() => {
                    let currentTestName = '';
                    let testGroupIndex = -1;
                    let isFirstInGroup = true;
                    let testGroupData = [];
                    let testGroupId = '';
                    let testGroupCount = 0;
                    
                    return categoryData.tests.map((test, testIndex) => {
                      const flag = test.flag ? test.flag.toLowerCase() : '';
                      const valueClass = (flag === 'h' || flag === 'high') ? 'high' : ((flag === 'l' || flag === 'low') ? 'low' : '');
                      const flagClass = (flag === 'h' || flag === 'high') ? 'h' : ((flag === 'l' || flag === 'low') ? 'l' : '');
                      
                      // Process value to remove flag if it's already in the flag column
                      let processedValue = test.value || '-';
                      if (test.flag && processedValue !== '-') {
                        // Remove H, L, High, or Low from before or after the value if flag exists
                        // Pattern handles: "H 140", "140 H", "H140", "140H", "H  140", "140  H", etc.
                        processedValue = processedValue
                          .replace(/^\s*(H|L|High|Low)\s+/i, '') // Remove from beginning with spaces
                          .replace(/\s+(H|L|High|Low)\s*$/i, '') // Remove from end with spaces
                          .replace(/^(H|L|High|Low)(?=\d)/i, '') // Remove flag directly before number
                          .replace(/(?<=\d)(H|L|High|Low)$/i, '') // Remove flag directly after number
                          .trim();
                      }
                      
                      // Check if this is a new test group
                      const testName = test.normalized_name || test.name;
                      let isLastInGroup = false;
                      
                      if (testName !== currentTestName) {
                        currentTestName = testName;
                        testGroupIndex = (testGroupIndex + 1) % 5; // Cycle through 0-4 (5 colors)
                        isFirstInGroup = true;
                        testGroupId = `test-group-${catIndex}-${testIndex}`;
                        
                        // Collect all data points for this test group
                        testGroupData = [];
                        testGroupCount = 0;
                        for (let i = testIndex; i < categoryData.tests.length; i++) {
                          const t = categoryData.tests[i];
                          if ((t.normalized_name || t.name) === testName) {
                            testGroupCount++;
                            if (t.date && t.value && t.value !== '-') {
                              testGroupData.push({
                                date: t.date.split(' ')[0],
                                value: t.value,
                                flag: t.flag
                              });
                            }
                          } else {
                            break;
                          }
                        }
                      } else {
                        isFirstInGroup = false;
                      }
                      
                      // Check if this is the last row in the group
                      const nextTest = categoryData.tests[testIndex + 1];
                      if (!nextTest || (nextTest.normalized_name || nextTest.name) !== testName) {
                        isLastInGroup = true;
                      }
                      
                      // Format date to remove time
                      const formatDate = (dateStr) => {
                        if (!dateStr) return '-';
                        const date = dateStr.split(' ')[0];
                        return date || dateStr;
                      };
                      
                      // Build class list for the row  
                      const rowClasses = [];
                      const hasMultipleResults = testGroupCount > 1;
                      
                      if (isFirstInGroup) {
                        rowClasses.push('test-group-first');
                        if (hasMultipleResults) {
                          rowClasses.push('test-group-expandable');
                        }
                      } else if (hasMultipleResults) {
                        rowClasses.push('test-group-collapsed');
                        rowClasses.push(`${testGroupId}-child`);
                      }
                      
                      // Add last-in-group class for proper border styling
                      if (isLastInGroup) {
                        rowClasses.push('test-group-last');
                      }
                      
                      // Generate sparkline only for first row of test group with multiple results
                      let sparklineCell = '<td class="test-chart"></td>';
                      if (isFirstInGroup && testGroupData.length > 1 && globalStartDate && globalEndDate) {
                        // Determine flag for coloring (use most recent flag or any H/L flag in the group)
                        const hasAbnormalFlag = testGroupData.some(d => d.flag && (d.flag.toLowerCase() === 'h' || d.flag.toLowerCase() === 'l'));
                        const sparklineFlag = hasAbnormalFlag ? 'h' : null;
                        
                        const sparkline = createLabSparkline(testGroupData, {
                          flag: sparklineFlag,
                          startDate: globalStartDate.toISOString().split('T')[0],
                          endDate: globalEndDate.toISOString().split('T')[0]
                        });
                        sparklineCell = `<td class="test-chart">${sparkline}</td>`;
                      }
                      
                      // Add chevron in separate column for expandable groups
                      let chevronCell = '<td class="test-chevron"></td>';
                      if (isFirstInGroup && hasMultipleResults) {
                        chevronCell = `<td class="test-chevron">
                          <span class="test-group-chevron" id="${testGroupId}-chevron">▶</span>
                        </td>`;
                      }
                      
                      const clickHandler = isFirstInGroup && hasMultipleResults ? 
                        `onclick="toggleTestGroup('${testGroupId}')" style="cursor: pointer;"` : '';
                      
                      // Add title attributes for tooltips
                      const testNameTooltip = test.normalized_name || '';
                      const valueTooltip = processedValue;
                      const rangeTooltip = test.reference_range || '-';
                      const unitTooltip = test.unit || '';
                      
                      return `
                        <tr class="${rowClasses.join(' ')}" ${clickHandler}>
                          ${chevronCell}
                          <td class="test-name" title="${escapeHtml(testNameTooltip)}">${escapeHtml(test.normalized_name || '')}</td>
                          <td class="test-value ${valueClass}" title="${escapeHtml(valueTooltip)}">
                            ${escapeHtml(processedValue)}
                          </td>
                          <td class="test-unit" title="${escapeHtml(unitTooltip)}">${escapeHtml(test.unit || '')}</td>
                          <td class="test-range" title="${escapeHtml(rangeTooltip)}">${escapeHtml(test.reference_range || '-')}</td>
                          <td class="test-flag">
                            ${test.flag ? `<span class="flag-indicator ${flagClass}">${escapeHtml(test.flag)}</span>` : '-'}
                          </td>
                          <td class="test-date">${escapeHtml(formatDate(test.date))}</td>
                          ${sparklineCell}
                        </tr>
                      `;
                    }).join('');
                  })()}
                </tbody>
              </table>
            </div>
          </div>
          ${(() => {
            // Collect test-specific notes grouped by test name
            const notesByTest = {};
            
            // Group notes by unique test name
            categoryData.tests.forEach(test => {
              if (test.notes && test.notes.trim()) {
                const testName = test.normalized_name || test.name;
                if (!notesByTest[testName]) {
                  notesByTest[testName] = new Set();
                }
                // Use Set to automatically handle duplicates
                notesByTest[testName].add(test.notes);
              }
            });
            
            // Count total unique notes
            const totalNotesCount = Object.values(notesByTest).reduce((sum, notesSet) => sum + notesSet.size, 0);
            
            // Only show notes section if there are test-specific notes
            if (totalNotesCount > 0) {
              const notesId = `notes-${cardId}`;
              return `
                <table class="table test-table notes-table">
                  <tbody>
                    <tr class="notes-header-row" onclick="toggleNotes('${notesId}')" style="cursor: pointer;">
                      <td style="width: 30px;" class="test-chevron">
                        <span class="notes-chevron" id="${notesId}-chevron">▶</span>
                      </td>
                      <td colspan="7" style="color: #6b7280; font-size: 0.813rem;">Notes (${totalNotesCount})</td>
                    </tr>
                    ${Object.entries(notesByTest).map(([testName, notesSet]) => {
                      const notesArray = Array.from(notesSet);
                      return notesArray.map(note => `
                        <tr class="notes-detail-row ${notesId}-child test-group-collapsed">
                          <td style="width: 30px;"></td>
                          <td colspan="7" style="color: #6b7280; font-size: 0.813rem; padding-left: 1rem;">
                            <strong>${escapeHtml(testName)}</strong>: ${escapeHtml(note)}
                          </td>
                        </tr>
                      `).join('');
                    }).join('')}
                  </tbody>
                </table>
              `;
            }
            return '';
          })()}
        `;
      });

      // Add processing time if available
      if (data.processing_time) {
        html += `
          <div style="text-align: center; color: #6b7280; font-size: 0.875rem; margin-top: 1rem;">
            Processed in ${(data.processing_time / 1000).toFixed(1)} seconds
          </div>
        `;
      }

      content.innerHTML = html;
    }

    // Global toggle function for notes (using same pattern as test groups)
    window.toggleNotes = function(notesId) {
      const childRows = document.querySelectorAll(`.${notesId}-child`);
      const chevron = document.getElementById(`${notesId}-chevron`);
      
      if (childRows.length > 0) {
        const isExpanded = childRows[0].classList.contains('show');
        
        childRows.forEach(row => {
          if (isExpanded) {
            row.classList.remove('show');
          } else {
            row.classList.add('show');
          }
        });
        
        if (chevron) {
          if (isExpanded) {
            chevron.textContent = '▶';
          } else {
            chevron.textContent = '▼';
          }
        }
      }
    };

    // Global toggle function for test groups
    window.toggleTestGroup = function(groupId) {
      const childRows = document.querySelectorAll(`.${groupId}-child`);
      const chevron = document.getElementById(`${groupId}-chevron`);
      const parentRow = chevron ? chevron.closest('tr') : null;
      
      if (childRows.length > 0) {
        const isExpanded = childRows[0].classList.contains('show');
        
        childRows.forEach(row => {
          if (isExpanded) {
            row.classList.remove('show');
          } else {
            row.classList.add('show');
          }
        });
        
        if (chevron) {
          if (isExpanded) {
            chevron.textContent = '▶';
            if (parentRow) {
              parentRow.classList.remove('has-expanded-children');
            }
          } else {
            chevron.textContent = '▼';
            if (parentRow) {
              parentRow.classList.add('has-expanded-children');
            }
          }
        }
      }
    };

    function exportToCSV(data) {
      const headers = [['Source File', 'Date', 'Original Category', 'Normalized Category', 'Test Name', 'Normalized Name', 'Result', 'Unit', 'Reference Range', 'Flag', 'Notes']];
      const dataRows = [];
      
      // Collect all data rows first
      if (data.combined_results) {
        data.combined_results.forEach(fileData => {
          const sourceFile = fileData.source_file || 'Unknown';
          
          if (fileData.results && Array.isArray(fileData.results)) {
            fileData.results.forEach(category => {
              const categoryName = category.category || 'Uncategorized';
              const testDate = fileData.lab_info?.date_collected || fileData.lab_info?.date_reported || '';
              
              if (category.tests) {
                category.tests.forEach(test => {
                  // Process value to remove flag if it's already in the flag column
                  let processedValue = test.value || '';
                  if (test.flag && processedValue) {
                    // Remove H, L, High, or Low from before or after the value if flag exists
                    // Pattern handles: "H 140", "140 H", "H140", "140H", "H  140", "140  H", etc.
                    processedValue = processedValue
                      .replace(/^\s*(H|L|High|Low)\s+/i, '') // Remove from beginning with spaces
                      .replace(/\s+(H|L|High|Low)\s*$/i, '') // Remove from end with spaces
                      .replace(/^(H|L|High|Low)(?=\d)/i, '') // Remove flag directly before number
                      .replace(/(?<=\d)(H|L|High|Low)$/i, '') // Remove flag directly after number
                      .trim();
                  }
                  
                  dataRows.push([
                    sourceFile,
                    testDate,
                    categoryName,
                    test.normalized_category || '',
                    test.name || '',
                    test.normalized_name || '',
                    processedValue,
                    test.unit || '',
                    test.reference_range || '',
                    test.flag || '',
                    test.notes || ''
                  ]);
                });
              }
            });
          }
        });
      }

      // Sort data rows by: 1) Normalized Category, 2) Normalized Name, 3) Date
      dataRows.sort((a, b) => {
        // First sort by normalized category (index 3)
        const catA = (a[3] || '').toLowerCase().trim();
        const catB = (b[3] || '').toLowerCase().trim();
        if (catA !== catB) {
          // Put empty categories at the end
          if (!catA) return 1;
          if (!catB) return -1;
          return catA.localeCompare(catB);
        }
        
        // Then sort by normalized name (index 5)
        const nameA = (a[5] || '').toLowerCase().trim();
        const nameB = (b[5] || '').toLowerCase().trim();
        if (nameA !== nameB) {
          // Put empty names at the end
          if (!nameA) return 1;
          if (!nameB) return -1;
          return nameA.localeCompare(nameB);
        }
        
        // Finally sort by date (index 1)
        // Parse dates to ensure proper chronological sorting
        const dateA = a[1] || '';
        const dateB = b[1] || '';
        if (dateA !== dateB) {
          // Try to parse as dates for proper chronological sorting
          const parsedA = Date.parse(dateA);
          const parsedB = Date.parse(dateB);
          if (!isNaN(parsedA) && !isNaN(parsedB)) {
            return parsedA - parsedB;
          }
          // Fallback to string comparison if date parsing fails
          return dateA.localeCompare(dateB);
        }
        
        // If everything else is equal, maintain original order
        return 0;
      });

      // Combine headers with sorted data
      const rows = [...headers, ...dataRows];

      const csv = rows.map(row => row.map(cell => `"${String(cell).replace(/"/g, '""')}"`).join(',')).join('\n');
      const blob = new Blob([csv], { type: 'text/csv' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `lab-results-${new Date().toISOString().split('T')[0]}.csv`;
      a.click();
      URL.revokeObjectURL(url);
    }
  }

  document.addEventListener('DOMContentLoaded', () => {
    initResultsTable(id);
  });
</script>